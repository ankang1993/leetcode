# 327.给定int数组nums，返回数值和在[lower, upper]内的nums的不同起止点的数量
1. 构建long数组保存到当前位置的数字的和
2. 利用归并排序算法进行求解：如果左右边界相同，返回0
3. 构建long数组sortArr，保存在当前范围内的排序结果
4. 调用函数递归求解左右两部分的结果，将结果的和赋给变量count
5. 利用遍历j、k保存在[lower, upper]的数字和的左右边界，p保存下一个要保存进sortArr的位置
6. 遍历左部分的数字，只要j指向数字和当前数字的差小于lower，j++；只要k指向数字和当前数字的差小于等于upper，k++。k与j的差即为满足在当前范围内数值和在[lower, upper]内的以当前数字为起点的数量，将差值加入count
7. 将右部分小于当前数字的数字加入sortArr，最后将当前数字加入sortArr
8. 将sortArr内排好序的部分赋回sums对应的位置
9. 返回在当前范围内数值和在[lower, upper]内的不同起止点的数量count
```
    public int countRangeSum(int[] nums, int lower, int upper) {
        int len = nums.length;
        long[] sums = new long[len + 1];
        for (int i = 0; i < len; i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
        return helper(sums, 0, len, lower, upper);
    }
    private int helper(long[] sums, int left, int right, int lower, int upper) {
        if (left == right) return 0;
        long[] sortArr = new long[right - left + 1];
        int index = 0, mid = left + (right - left) / 2;
        int count = helper(sums, left, mid, lower, upper) + helper(sums, mid + 1, right, lower, upper);
        int j = mid + 1, k = mid + 1, p = mid + 1;
        for (int i = left; i <= mid; i++) {
            while (j <= right && sums[j] - sums[i] < lower) j++;
            while (k <= right && sums[k] - sums[i] <= upper) k++;
            count += k - j;
            while (p <= right && sums[p] < sums[i]) {
                sortArr[index] = sums[p];
                index++;
                p++;
            }
            sortArr[index] = sums[i];
            index++;
        }
        for (int i = left; i < p; i++) {
            sums[i] = sortArr[i - left];
        }
        return count;
    }
```

# 328.给定一条链表，将所有偶数位置的点连接到奇数位置的点的后面
1. 如果head为null，返回null
2. 构建变量odd指向第一个位置的节点，even指向第二个位置的节点，evenHead指向even链表的头节点
3. 只要even和even.next不为null，就进入循环：将even.next赋给odd.next，让odd指向odd.next;将odd.next赋给even的next，将even指向even.next
4. 将evenHead赋给odd的next
5. 返回head
```
    public ListNode oddEvenList(ListNode head) {
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
```
