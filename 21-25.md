# 21.合并两个已排序的单链表
1. 构建新头
2. 只要两个链表当前都不为null，就进入循环，将值较小的节点加入新链表里
3. 退出循环后，将剩余节点接入新链表
```
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0), cur = head;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            }
            else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 != null) cur.next = l1;
        else cur.next = l2;
        return head.next;
    }
```

# 22.给定圆括号的对数n，生成所有的合法的圆括号组合
1. 构建数组
2. 调用函数生成组合
3. 如果左括号和右括号剩余的数量均为0，加入返回集
4. 如果左括号剩余数量大于0，加入左括号，调用函数
5. 如果右括号剩余数量大于0，加入右括号，调用函数
```
    public List<String> generateParenthesis(int n) {
        char[] arr = new char[n * 2];
        ArrayList<String> ret = new ArrayList<>();
        helper(ret, arr, 0, n, 0);
        return ret;
    }
    private void helper(ArrayList<String> ret, char[] arr, int index, int leftRemain, int rightRemain) {
        if (leftRemain == 0 && rightRemain == 0) {
            ret.add(String.valueOf(arr));
            return;
        }
        if (leftRemain > 0) {
            arr[index] = '(';
            helper(ret, arr, index + 1, leftRemain - 1, rightRemain + 1);
        }
        if (rightRemain > 0) {
            arr[index] = ')';
            helper(ret, arr, index + 1, leftRemain, rightRemain - 1);
        }
    }
```
