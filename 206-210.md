# 206.将单链表的节点进行反转

+ 方法一：遍历链表，将当前节点的next指向前一个节点

+ 方法二：递归调用函数将当前节点的下一个节点之后的链表进行反转，将当前节点连接到反转之后的链表之后

```
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode old = head, cur = head.next;
        old.next = null;
        while (cur != null) {
            ListNode node = cur.next;
            cur.next = old;
            old = cur;
            cur = node;
        }
        return old;
    }
```
```
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode node = head.next;
        ListNode newHead = reverseList(node);
        node.next = head;
        head.next = null;
        return newHead;
    }
```

# 207.判断给定的有向图是否存在环
1. 利用拓扑排序法进行求解，遍历边集合，保存各个顶点的入度和以该顶点为起始点的边的终止点
2. 利用变量count保存拓扑排序的更新过程中，入度为0的顶点数量
3. 将入度为0的顶点加入队列，只要队列不为空，就进入循环：弹出队列首元素，将以该顶点为起始点的边的终止点入度减1，如果入度为0，加入队列
4. 退出循环后，如果count的值不等于给定的所有顶点的数量，说明存在环；否则，不存在
```
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] degree = new int[numCourses];
        int count = 0;
        ArrayList[] edges = new ArrayList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            edges[i] = new ArrayList();
        }
        for (int[] edge : prerequisites) {
            degree[edge[0]]++;
            edges[edge[1]].add(edge[0]);
        }
        LinkedList<Integer> list = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (degree[i] == 0) {
                list.add(i);
                count++;
            }
        }
        while (list.size() > 0) {
            for (int i = 0, size = list.size(); i < size; i++) {
                for (Object obj : edges[list.poll()]) {
                    int num = (int)obj;
                    degree[num]--;
                    if (degree[num] == 0) {
                        list.add(num);
                        count++;
                    }
                }
            }
        }
        if (count != numCourses) return false;
        return true;
    }
```

# 208.设计实现前缀树（字符为‘a’-‘z’），功能包括插入、查询字符串及查找是否存在以给定字符串开头的字符串
1. 构建私有类Node，保存当前对象的下一个Node数组next，是否为字符串末尾的标志leaf
2. 构造函数：创建头节点root
3. 插入函数：构建当前节点变量cur，指向头节点root。遍历字符串，如果当前节点的next数组里，保存当前字符的节点为null，就创建新节点保存，并让cur指向新节点，继续循环。保存完所有字符后，将最后节点的leaf状态置true，代表字符串的末尾
4. 查询字符串函数：构建当前节点变量cur，指向头节点root。遍历字符串，如果当前节点的next数组里，保存当前字符的节点为null，说明树中没有保存过该字符串，返回false；否则，让cur指向该节点，继续循环判断。退出循环后，判断当前节点的leaf是否为true，如果不是，代表树中未保存该字符串，返回false；否则，返回true
5. 查找是否存在以给定字符串开头的字符串函数：构建当前节点变量cur，指向头节点root。遍历字符串，如果当前节点的next数组里，保存当前字符的节点为null，说明树中没有保存过以该字符串为开头的字符串，返回false；否则，让cur指向该节点，继续循环判断。如果正常退出循环，代表树中保存了以该字符串为开头的字符串，返回true
```
    private class Node {
        Node[] next;
        boolean leaf;
        public Node() {
            next = new Node[26];
            leaf = false;
        }
    }
    Node root;
    /** Initialize your data structure here. */
    public Trie() {
        root = new Node();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Node cur = root;
        for (char ch : word.toCharArray()) {
            if (cur.next[ch - 'a'] == null) cur.next[ch - 'a'] = new Node();
            cur = cur.next[ch - 'a'];
        }
        cur.leaf = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Node cur = root;
        for (char ch : word.toCharArray()) {
            cur = cur.next[ch - 'a'];
            if (cur == null) return false;
        }
        return cur.leaf == true;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Node cur = root;
        for (char ch : prefix.toCharArray()) {
            cur = cur.next[ch - 'a'];
            if (cur == null) return false;
        }
        return true;
    }
```
