# 146.利用插入法对链表进行排序
1. 构建虚假头，并将原链表的首元素连接到其后，断开首元素与其他元素的连接
2. 遍历链表，对当前元素寻找在新链中应存放的位置后进行插入
```
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = head.next;
        dummy.next.next = null;
        while (head != null) {
            ListNode left = dummy, right = dummy.next, nextNode = head.next;
            while (right != null && right.val <= head.val) {
                left = right;
                right = right.next;
            }
            left.next = head;
            head.next = right;
            head = nextNode;
        }
        return dummy.next;
    }
```

# 148.利用常数空间O（nlongn）的时间复杂度对链表进行排序

利用归并排序法对链表进行排序
1. 利用快速和慢速指针找到链表当前范围内的中间节点，对左右两部分的链表递归进行排序
2. 对已排好序的两个链表进行组合，将排好序的新链表返回
```
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode fast = head, slow = head, old = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            old = slow;
            slow = slow.next;
        }
        old.next = null;
        ListNode leftList = sortList(head), rightList = sortList(slow);
        ListNode dummy = new ListNode(0), cur = dummy;
        while (leftList != null && rightList != null) {
            if (leftList.val < rightList.val) {
                cur.next = leftList;
                leftList = leftList.next;
            }
            else {
                cur.next = rightList;
                rightList = rightList.next;
            }
            cur = cur.next;
        }
        if (leftList != null) cur.next = leftList;
        if (rightList != null) cur.next = rightList;
        return dummy.next;
    }
```

# 150.根据给定的逆波兰表达式计算结果
1. 构建数组模仿栈，用于存放操纵数
2. 遍历表达式，如果当前元素是数字，就将其压入栈；否则，弹出栈顶的两个元素，根据当前元素操作符进行运算，将结果压入栈
```
    public int evalRPN(String[] tokens) {
        int len = tokens.length;
        int[] stack = new int[len];
        int index = 0;
        for (int i = 0; i < len; i++) {
            if (tokens[i].equals("+")) {
                int a = stack[index - 2], b = stack[index - 1];
                stack[index - 2] = a + b;
                index--;
            }
            else if (tokens[i].equals("-")) {
                int a = stack[index - 2], b = stack[index - 1];
                stack[index - 2] = a - b;
                index--;
            }
            else if (tokens[i].equals("*")) {
                int a = stack[index - 2], b = stack[index - 1];
                stack[index - 2] = a * b;
                index--;
            }
            else if (tokens[i].equals("/")) {
                int a = stack[index - 2], b = stack[index - 1];
                stack[index - 2] = a / b;
                index--;
            }
            else {
                stack[index] = Integer.valueOf(tokens[i]);
                index++;
            }
        }
        return stack[0];
    }
```
