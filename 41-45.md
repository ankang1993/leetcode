# 41.寻找第一个消失的整数（O(n)复杂度，常数额外空间）
1. 循环遍历数组，将正常元素放到它应该存放的位置：如果当前元素不在1~len之间，继续；如果当前元素正是应该放在当前位置，或是以当前元素作为索引得到的元素放在了正确的位置，则继续；否则，将当前元素和以该元素作为索引的元素进行交换
2. 遍历数组，如果当前元素不应该存放在当前位置，则返回
```
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        if (len == 0) return 1;
        for (int i = 0; i < len; i++) {
            if (nums[i] < 1 || nums[i] > len) continue;
            if (nums[i] == i + 1 || nums[nums[i] - 1] == nums[i]) continue;
            int tmp = nums[i], index = nums[i] - 1;
            nums[i] = nums[index];
            nums[index] = tmp;
            i--;
        }
        for (int i = 0; i < len; i++) {
            if (nums[i] != i + 1) return i + 1;
        }
        return len + 1;
    }
```

# 42.
