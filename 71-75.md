# 71.给定一个文件的绝对路径（Unix风格），简化它
1. 根据“/”对字符串进行分割，构建指针index，指向简化后当前字符串
2. 遍历字符串数组，如果当前字符串为“”或者“.”，继续；如果是“..”，指针减1；其他则将当前字符串复制到index指针指向的位置，index自增
3. 如果index指向起始位置，说明简化后没有路径，则返回根目录“/”；否则构建简化路径返回
```
    public String simplifyPath(String path) {
        String[] arr = path.split("/");
        int index = 0;
        for (int i = 0, len = arr.length; i < len; i++) {
            if (arr[i].equals("") || arr[i].equals(".")) continue;
            else if (arr[i].equals("..")) {
                if (index > 0) index--;
            }
            else {
                arr[index] = arr[i];
                index++;
            }
        }
        if (index == 0) return "/";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < index; i++) {
            sb.append("/");
            sb.append(arr[i]);
        }
        return sb.toString();
    }
```

# 72.给定两个字符串，找到需要最少步数使得字符串1转换为字符串2（步骤包括：增加一个字符，删除一个字符，替换一个字符）

动态规划：

状态：到字符串1的第i个位置和字符串2的第j个位置时，所需要的最小步数；

状态转移方程：如果字符串1的第i个位置和字符串2的第j个位置的字符相同，说明不需要进行任何操作，则状态值等于动态数组dp[i-1][j-1]；否则，状态值等于动态数组dp[i - 1][j]、dp[i][j - 1]和dp[i - 1][j - 1]中的最小值+1，即从删除一个字符、增加一个字符和替换一个字符里选择所需步数最小的那个操作

```
    public int minDistance(String word1, String word2) {
        int len1 = word1.length(), len2 = word2.length();
        if (len1 == 0) return len2;
        if (len2 == 0) return len1;
        char[] arr1 = word1.toCharArray(), arr2 = word2.toCharArray();
        int[][] dp = new int[len1 + 1][len2 + 1];
        for (int i = 1; i <= len1; i++) dp[i][0] = i;
        for (int j = 1; j <= len2; j++) dp[0][j] = j;
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (arr1[i - 1] == arr2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
            }
        }
        return dp[len1][len2];
    }
```

# 73.给定一个矩阵，如果某个位置的元素为0，则将其行和列的所有元素都置0
1. 设置标志flag，如果只有第一行有元素为0，则flag的二进制形式为01；如果只有第一列有元素为0 ，则flag的二进制形式为10；如果第一行和第一列都有元素为0，则flag的二进制形式为1
2. 遍历数组，如果某元素为0，则将其对应的第一行和第一列的位置的元素置0
3. 遍历第一行和第一列除[0][0]位置，如果元素为0，则置对应的列和行所有元素为0
4. 如果[0][0]位置元素为0，检验标志flag，根据二进制形式将第一行和第一列进行置0操作
```
    public void setZeroes(int[][] matrix) {
        int row = matrix.length, col = matrix[0].length, flag = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    if (j == 0) flag = flag | 1;
                    matrix[i][0] = 0;
                    if (i == 0) flag = flag | 2;
                }
            }
        }
        for (int i = 1; i < row; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 0; j < col; j++) matrix[i][j] = 0;
            }
        }
        for (int j = 1; j < col; j++) {
            if (matrix[0][j] == 0) {
                for (int i = 0; i < row; i++) matrix[i][j] = 0;
            }
        }
        if (matrix[0][0] == 0) {
            if ((flag & 1) == 1) {
                for (int i = 1; i < row; i++) matrix[i][0] = 0;
            }
            if ((flag & 2) == 2) {
                for (int j = 1; j < col; j++) matrix[0][j] = 0;
            }
        }
    }
```
