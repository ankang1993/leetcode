# 241.给定一个包含数字和运算符‘+’、‘-’、‘*’的字符串，返回通过在字符串内不同位置加括号产生的所有可能的结果
1. 利用HashMap保存已经计算过的结果，利用分治算法调用函数递归进行求解
2. 如果HashMap里保存过该关键字，直接返回结果
3. 遍历当前范围的字符，如果遇到运算符，调用函数递归求解运算符左右部分的解，并对解进行组合，将结果加入结果集；如果遇到数字，加入num变量组成最终数字
4. 如果结果集为空，说明当前范围内没有运算符，将num值加入结果集
5. 将关键字和结果集加入HashMap
6. 返回结果集
```
    private HashMap<String, List<Integer>> map = new HashMap<>();
    public List<Integer> diffWaysToCompute(String input) {
        int len = input.length();
        if (len == 0) return new ArrayList<>();
        return helper(input.toCharArray(), 0, len - 1);
    }
    private List<Integer> helper(char[] chs, int left, int right) {
        String key = left + "," + right;
        List<Integer> ret = map.get(key);
        if (ret != null) return ret;
        ret = new ArrayList<>();
        int num = 0;
        for (int i = left; i <= right; i++) {
            if (chs[i] == '+' || chs[i] == '-' || chs[i] == '*') {
                List<Integer> leftList = helper(chs, left, i - 1), rightList = helper(chs, i + 1, right);
                for (int num1 : leftList) {
                    for (int num2 : rightList) {
                        if (chs[i] == '+') ret.add(num1 + num2);
                        else if (chs[i] == '-') ret.add(num1 - num2);
                        else ret.add(num1 * num2);
                    }
                }
            }
            else num = num * 10 + chs[i] - '0';
        }
        if (ret.isEmpty()) ret.add(num);
        map.put(key, ret);
        return ret;
    }
```

# 242.判断字符串t是否是字符串s的字符组成的
1. 如果两个字符串的长度不同，返回false
2. 构建数组arr保存每个字符出现的次数
3. 遍历字符串s，在数组arr对应的位置上+1
4. 遍历字符串t，如果数组arr对应的位置上值为0，返回false；否则，对应值-1
```
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        int[] arr = new int[256];
        for (char ch : s.toCharArray()) {
            arr[ch - '0']++;
        }
        for (char ch : t.toCharArray()) {
            if (arr[ch - '0'] == 0) return false;
            arr[ch - '0']--;
        }
        return true;
    }
```
