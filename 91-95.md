# 91.‘A’-‘Z’被编码为1-26，给定只包含数字的字符串，求有几种解码结果
1. 如果字符串长度为0，或首元素为0，则直接返回0
2. 构建动态数组dp，状态为到当前位置解码结果的个数。第一个和第二个位置存1
3. 从字符串第二个元素开始遍历，如果不为0，则令当前状态等于前一个状态，将当前元素和前一个元素合起来，如果值大于9，小于27，则当前状态需要再加上前一个的前一个状态
```
    public int numDecodings(String s) {
        int len = s.length();
        if (len == 0) return 0;
        char[] arr = s.toCharArray();
        if (arr[0] == '0') return 0;
        int[] dp = new int[len + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= len; i++) {
            if (arr[i - 1] != '0') dp[i] = dp[i - 1];
            int num = (arr[i - 2] - '0') * 10 + arr[i - 1] - '0';
            if (9 < num && num < 27) dp[i] += dp[i - 2];
        }
        return dp[len];
    }
```

# 92.将链表的第m个和第n个直接的元素反转
1. 构建指针移动到第m个元素位置
2. 排着将m和n直接的元素进行反转连接
3. 将反转之后的元素连接到原链表里
```
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (m == n) return head;
        ListNode newHead = new ListNode(0);
        newHead.next = head;
        ListNode cur = newHead, left = cur;
        int index = 0;
        while (index < m) {
            left = cur;
            cur = cur.next;
            index++;
        }
        ListNode end = cur, old = cur, right = cur.next;
        while (index < n) {
            cur = right;
            right = right.next;
            cur.next = old;
            old = cur;
            index++;
        }
        left.next = cur;
        end.next = right;
        return newHead.next;
    }
```

# 93.给定一个只包含数字的字符串，返回能组合成的所有合法ip地址
1. 利用回溯法进行递归求解，如果已经遍历完字符串且已存放4个数字，将当前结果加入结果集
2. 如果当前数字是0，则进行递归求解；否则继续加入新字符，如果新值满足条件，则进行递归求解
```
    public List<String> restoreIpAddresses(String s) {
        List<String> ret = new ArrayList<>();
        if (s.equals("")) return ret;
        helper(ret, s.toCharArray(), new int[4], 0, 0);
        return ret;
    }
    private void helper(List<String> ret, char[] arr, int[] ip, int index, int count) {
        int len = arr.length;
        if (index == len && count == 4) {
            String str = "";
            for (int i = 0; i < 3; i++) str += ip[i] + ".";
            str += ip[3];
            ret.add(str);
            return;
        }
        if (index == len || count >= 4) return;
        int num = arr[index] - '0';
        ip[count] = num;
        helper(ret, arr, ip, index + 1, count + 1);
        if (num != 0) {
            for (int i = index + 1, end = index + 3; i < len && i < end; i++) {
                num = num * 10 + (arr[i] - '0');
                ip[count] = num;
                if (0 < num && num <= 255) helper(ret, arr, ip, i + 1, count + 1);
            }
        }
    }
```
