# 297.设计算法实现二叉树的序列化和反序列化
1. 序列化：利用层序遍历，将当前节点的左右节点加入序列化结果中，用‘,’进行分割。如果当前节点的左节点非null，就将左节点加入队列，如果当前节点的右节点非null，就将右节点加入队列
2. 反序列化：根据‘,’对字符串进行分割，遍历分割结果，如果当前值不是空，则利用当前值构建节点，连接到父节点上，并将其加入队列准备利用下面的数值更新其左右节点
```
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "";
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        sb.append(root.val);
        sb.append(',');
        while (!queue.isEmpty()) {
            StringBuilder tmp = new StringBuilder();
            for (int i = 0, end = queue.size(); i < end; i++) {
                TreeNode cur = queue.poll();
                if (cur.left != null) {
                    tmp.append(cur.left.val);
                    queue.add(cur.left);
                }
                else tmp.append('N');
                tmp.append(',');
                if (cur.right != null) {
                    tmp.append(cur.right.val);
                    queue.add(cur.right);
                }
                else tmp.append('N');
                tmp.append(',');
            }
            if (!queue.isEmpty()) sb.append(tmp);
        }
        return sb.substring(0, sb.length() - 1);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null || data.length() == 0) return null;
        String[] strs = data.split(",");
        TreeNode root = new TreeNode(Integer.valueOf(strs[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        for (int i = 1, len = strs.length; i < len; ) {
            TreeNode cur = queue.poll();
            if (!strs[i].equals("N")) {
                TreeNode tmp = new TreeNode(Integer.valueOf(strs[i]));
                cur.left = tmp;
                queue.add(tmp);
            }
            i++;
            if (!strs[i].equals("N")) {
                TreeNode tmp = new TreeNode(Integer.valueOf(strs[i]));
                cur.right = tmp;
                queue.add(tmp);
            }
            i++;
        }
        return root;
    }
```
