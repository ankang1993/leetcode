# 96.给定int数n，返回包含1-n的不同结构的二叉搜索树的数量
1. 利用动态规划数组保存有i个节点时，不同结构二叉搜索树的数量
2. 从1到n排着求解，当节点数量是i时，左子树节点数量从0到i变化，利用不同左子树的数量乘不同右子树的数量来计算此时节点数量是i的不同二叉搜索树的数量
```
    public int numTrees(int n) {
        if (n == 0) return 0;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```

# 100.给定两个个二叉树，判断是否结构相同值相等
1. 如果两个二叉树的当前节点均为空，则返回true
2. 如果其中一个为空另一个非空，返回false
3. 如果两个节点值不等，返回false
4. 递归判断左节点和右节点是否相等
```
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
```
