# 307.给定一个数组，元素可变，设计算法返回给定边界内的数字和

利用树状数组sums优化数组元素的修改及求和的时间复杂度（树状数组中的每个元素是原数组中一个或者多个连续元素的和；在进行连续求和操作a[1]+...+a[n]时，只需要将树状数组中某几个元素的和即可。时间复杂度为O(lgn)；在进行修改某个元素a[i]时，只需要修改树状数组中某几个元素的和即可。时间复杂度为O(lgn)）
![](https://images0.cnblogs.com/i/466768/201406/112202138584692.png)
1. a[]: 保存原始数据的数组。(操作(1)求其中连续多个数的和，操作(2)任意修改其中一个元素)；e[]: 树状数组，其中的任意一个元素e[i]可能是一个或者多个a数组中元素的和。如e[2]=a[1]+a[2]; e[3]=a[3]; e[4]=a[1]+a[2]+a[3]+a[4]。 
2. e[i]是几个a数组中的元素的和？如果数字 i 的二进制表示中末尾有k个连续的0，则e[i]是a数组中2^k个元素的和，则e[i]=a[i-2^k+1]+a[i-2^k+2]+...+a[i-1]+a[i]。
如：4=100(2)：e[4]=a[1]+a[2]+a[3]+a[4]；6=110(2)：e[6]=a[5]+a[6]；7=111(2)：e[7]=a[7]
3. 后继：可以理解为节点的父亲节点。是离它最近的，且编号末位连续0比它多的就是它的父亲,如e[2]是e[1]的后继；e[4]是e[2]的后继。如e[4] = e[2]+e[3]+a[4] = a[1]+a[2]+a[3]+a[4] ，e[2]、e[3]的后继就是e[4]。后继主要是用来计算e数组，将当前已经计算出的e[i]添加到他们后继中。
4. 前驱：节点前驱的编号即为比自己小的，最近的，最末连续0比自己多的节点。如e[7]的前驱是e[6],e[6]的前驱是e[4]。前驱主要是在计算连续和时，避免重复添加元素。如：Sum(7)=a[1]+...+a[7]=e[7]+e[6]+e[4]。(e[7]的前驱是e[6], e[6]的前驱是e[4])
5. 计算前驱与后继：lowbit(i) = ( (i-1) ^ i) & i ;节点e[i]的前驱为 e[ i - lowbit(i) ]；节点e[i]的前驱为 e[ i + lowbit(i) ]
```
    private int[] sums, nums;
    private int len;
    public NumArray(int[] nums) {
        this.nums = nums;
        len = nums.length;
        sums = new int[len + 1];
        for (int i = 0; i < len; i++) {
            sums[i + 1] += nums[i];
            int parent = i + 1 + lowbit(i + 1);
            if (parent <= len) sums[parent] += sums[i + 1];
        }
    }
    
    public void update(int i, int val) {
        int diff = val - nums[i], parent = i + 1;
        nums[i] = val;
        while (parent <= len) {
            sums[parent] += diff;
            parent += lowbit(parent);
        }
    }
    
    public int sumRange(int i, int j) {
        int ret = 0, cur = j + 1;
        while (cur > 0) {
            ret += sums[cur];
            cur -= lowbit(cur);
        }
        cur = i;
        while (cur > 0) {
            ret -= sums[cur];
            cur -= lowbit(cur);
        }
        return ret;
    }
    
    private int lowbit(int i) {
        return (i ^ (i - 1)) & i;
    }
```
