# 26.给定有序数组，在原来的位置上除去重复元素，返回新数组的长度
1. 设置位置指针
2. 如果当前元素和上一个元素不同，则保存当前元素，位置指针右移
```
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        if (len < 2) return len;
        int res = 1;
        for (int i = 1; i < len; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[res] = nums[i];
                res++;
            }
        }
        return res;
    }
```

# 27. 在原来的位置上删除数组里出现的和目标数字一样的元素，返回新数组的长度
1. 设置位置指针
2 如果当前元素和目标数字不同，保存元素，位置指针右移
```
    public int removeElement(int[] nums, int val) {
        int len = nums.length;
        if (len == 0) return 0;
        int res = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] != val) {
                nums[res] = nums[i];
                res++;
            }
        }
        return res;
    }
```

# 28.实现字符串匹配算法
1. 构建next数组:数组第i个元素保存的是在模式串第i字符之前公共前缀和公共后缀的最大长度，next[0] = -1。已知next[j] = k，如果第j个字符和第k个字符相同，则next[j+1] = k + 1，否则令k = next[k]，循环求解，直到k = -1 或 第j个字符和第k个字符相同。 
2. 进行字符串匹配:
```
    public int strStr(String haystack, String needle) {
        int lenH = haystack.length(), lenN = needle.length();
        if (lenN == 0) return 0;
        if (lenH == 0) return -1;
        int[] next = new int[lenN];
        char[] arrH = haystack.toCharArray(), arrN = needle.toCharArray();
        helper(arrN, next);
        for (int i = 0, j = 0; i < lenH; i++) {
            while (j >= 0 && arrH[i] != arrN[j]) j = next[j];
            j++;
            if (j == lenN) return i - j + 1;
        }
        return -1;
    }
    private void helper(char[] arr, int[] next) {
        int k = -1, i = 0, len = arr.length;
        next[0] = -1;
        while (i < len - 1) {
            if (k == -1 || arr[i] == arr[k]) {
                i++;
                k++;
                if (arr[i] == arr[k]) next[i] = next[k];
                else next[i] = k;
            }
            else k = next[k];
        }
    }
```
