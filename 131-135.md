# 131.将字符串分割成子串的组合，要求子串均为回文字符串
1. 利用回溯法进行求解，如果当前位置为字符串末尾，则将当前组合加入结果集
2. 否则从当前位置开始，逐渐扩大子串长度，判断是否是回文字符串，如果是，则加入当前组合，继续递归调用函数求解
```
    public List<List<String>> partition(String s) {
        List<List<String>> ret = new ArrayList<List<String>>();
        helper(s.toCharArray(), 0, ret, new ArrayList<String>());
        return ret;
    }
    private void helper(char[] arr, int index, List<List<String>> ret, List<String> list) {
        int len = arr.length;
        if (index == len) {
            ret.add(new ArrayList<String>(list));
            return;
        }
        for (int i = index; i < len; i++) {
            if (isPalindrome(arr, index, i)) {
                list.add(new String(arr, index, i - index + 1));
                helper(arr, i + 1, ret, list);
                list.remove(list.size() - 1);
            }
        }
    }
    private boolean isPalindrome(char[] arr, int left, int right) {
        while (left < right) {
            if (arr[left] != arr[right]) return false;
            left++;
            right--;
        }
        return true;
    }
```

# 132.求解将字符串分割为子串均为回文字符串的最少分割数
1. 利用动态数组保存到当前位置时所需的最少分割数，长度为字符串长度+1，首元素赋-1，第二个元素赋0，代表字符串第一个元素需要的分割数为0
2. 遍历字符串，调用函数从当前字符开始向左右扩展，接着调用函数从当前字符和前一个字符开始向左右扩展
3. 函数内判断当前子串是否是回文字符串，如果是，更新动态数组，并且持续扩展子串直到子串不回文为止
```
    public int minCut(String s) {
        int len = s.length();
        char[] arr = s.toCharArray();
        int[] res = new int[len + 1];
        Arrays.fill(res, len);
        res[0] = -1;
        res[1] = 0;
        for (int i = 1; i < len; i++) {
            helper(arr, i, i, res);
            helper(arr, i - 1, i, res);
        }
        return res[len];
    }
    private void helper(char[] arr, int left, int right, int[] res) {
        int len = arr.length;
        while (left >= 0 && right < len && arr[left] == arr[right]) {
            res[right + 1] = Math.min(res[right + 1], res[left] + 1);
            left--;
            right++;
        }
    }
```

# 133.对给定的图结构进行克隆，图的点包含label值和邻接点链表
1. 如果给定点为空，返回；否则调用函数求解，利用HashMap保存已经构建的点
2. 如果map里包含所需的点，直接返回；否则，克隆该点，遍历要克隆的点的邻接点链表，克隆邻接点，并加入到该点的邻接点链表中
```
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if (node == null) return null;
        return helper(node, new HashMap<Integer, UndirectedGraphNode>());
    }
    private UndirectedGraphNode helper(UndirectedGraphNode node, HashMap<Integer, UndirectedGraphNode> map) {
        if (map.containsKey(node.label)) return map.get(node.label);
        UndirectedGraphNode root = new UndirectedGraphNode(node.label);
        map.put(root.label, root);
        for (UndirectedGraphNode tmp : node.neighbors) {
            root.neighbors.add(helper(tmp, map));
        }
        return root;
    }
```
