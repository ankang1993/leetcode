# 86.将链表里大于等于目标值的元素接到小于目标值的元素后面
1. 构建两个新头，分别接大于等于目标值和小于目标值的元素
2. 遍历链表，将元素根据大小接到两个新链后
3. 将两个新链连接起来返回
```
  public ListNode partition(ListNode head, int x) {
        ListNode ge = new ListNode(0), geHead = ge, l = new ListNode(0), newHead = l;
        while (head != null) {
            if (head.val >= x) {
                ge.next = head;
                ge = ge.next;
            }
            else {
                l.next = head;
                l = l.next;
            }
            head = head.next;
        }
        l.next = geHead.next;
        ge.next = null;
        return newHead.next;
    }
```

# 87.判断一个字符串是否是另一个字符串“变化形式”（可以迭代选择某个分界点，交换两个非空字串得到）
1. 构建动态规划数组，状态为第一个字符串在第i个位置，第二个字符串在第j个位置时，长度为k的字串是否满足条件
2. k从1到字符串的长度循环计算数组，如果k为1，则直接比较两个字符串对应的元素是否相等；否则，令变量m从1到k-1循环计算，如果以长度m划分字符串能令此时状态为真，则跳出循环

```
  public boolean isScramble(String s1, String s2) {
        int len = s1.length();
        if (len == 0) return true;
        char[] arr1 = s1.toCharArray(), arr2 = s2.toCharArray();
        boolean[][][] dp = new boolean[len][len][len + 1];
        for (int k = 1; k <= len; k++) {
            for (int i = 0; i <= len - k; i++) {
                for (int j = 0; j <= len - k; j++) {
                    if (k == 1) dp[i][j][k] = arr1[i] == arr2[j];
                    else {
                        for (int m = 1; m < k && !dp[i][j][k]; m++) {
                            dp[i][j][k] = (dp[i][j][m] && dp[i + m][j + m][k - m])
                                       || (dp[i][j + k - m][m] && dp[i + m][j][k - m]);
                        }
                    }
                }
            }
        }
        return dp[0][0][len];
    }
```

# 88.给定两个已排序的数组，将两个数组按顺序放到数组1里，数组1的空间足够
1. 构建指针index从位置m+n-1开始存放元素
2. 比较两个数组的元素大小，如果某个数组元素已全部用完，则将元素置int最小值，将较大的元素放入index指针指向的位置，对应指针左移
```
  public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = m - 1, j = n - 1, index = m + n - 1; i >= 0 || j >= 0; index--) {
            int num1 = i >= 0 ? nums1[i] : Integer.MIN_VALUE;
            int num2 = j >= 0 ? nums2[j] : Integer.MIN_VALUE;
            if (num1 < num2) {
                nums1[index] = num2;
                j--;
            }
            else {
                nums1[index] = num1;
                i--;
            }
        }
    }
```
